//
// Created by jhnidek on 24.11.25.
//

#include <gtest/gtest.h>
#include <fstream>
#include "productdb.hpp"

class ProductDbTest : public ::testing::Test {
protected:
    void SetUp() override {
        test_db.path = "test_product.json";
    }

    void TearDown() override {
        std::remove(test_db.path.c_str());
    }

    ProductDb test_db = ProductDb();
};

namespace  test_constructors {
    TEST_F(ProductDbTest, ConstructorWithouArguments) {
        const auto *db = new ProductDb();
        EXPECT_EQ(db->path, DEFAULT_PRODUCTDB_FILE);
        EXPECT_TRUE(db->products.empty());
        delete db;
    }

    TEST_F(ProductDbTest, ConstructorWithPathArgument) {
        const auto *db = new ProductDb("foo_product.json");
        EXPECT_EQ(db->path, "foo_product.json");
        EXPECT_TRUE(db->products.empty());
        delete db;
    }
}

namespace test_read_product_db {
    TEST_F(ProductDbTest, ReadEmptyDbPath) {
        test_db.path = "";
        EXPECT_THROW({
            try {
                test_db.read_product_db();
            } catch (std::runtime_error &e) {
                EXPECT_STREQ(e.what(), "Productdb file path is empty");
                throw;
            }
        }, std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }

    TEST_F(ProductDbTest, ReadWrongDbPath) {
        test_db.path = "./nonexistent_file.json";
        EXPECT_THROW({
            try {
                test_db.read_product_db();
            } catch (std::runtime_error &e) {
                EXPECT_STREQ(e.what(), "Unable to open productdb file: ./nonexistent_file.json");
                throw;
            }
        }, std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }

    TEST_F(ProductDbTest, ReadEmptyDb) {
        // Create an empty file first
        std::ofstream file(test_db.path);
        file.close();
        // It raises an exception with a very long message generated by a 3rd party library...
        EXPECT_THROW(test_db.read_product_db(), std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }

    TEST_F(ProductDbTest, ReadValidDb) {
        std::ofstream file(test_db.path);
        file << R"({"38091": ["repo1", "repo2"], "908": ["repo3"]})";
        file.close();
        EXPECT_TRUE(test_db.read_product_db());
        EXPECT_EQ(test_db.products.size(), 2);
        EXPECT_TRUE(test_db.has_product_id("38091"));
        EXPECT_TRUE(test_db.has_product_id("908"));
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo1"));
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo2"));
        EXPECT_TRUE(test_db.products["908"].has_repo_id("repo3"));
    }

    /// Test invalid db format #1 (root is not an object)
    TEST_F(ProductDbTest, ReadInvalidDb1) {
        std::ofstream file(test_db.path);
        file << R"([{"38091": {}}, {"908": {}}])";
        file.close();
        EXPECT_THROW({
            try {
                test_db.read_product_db();
            } catch (std::runtime_error &e) {
                EXPECT_STREQ(e.what(), "The productdb file: 'test_product.json' root value is not collection");
                throw;
            }
        }, std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }

    /// Test invalid db format #2 (values in the object are not arrays)
    TEST_F(ProductDbTest, ReadInvalidDb2) {
        std::ofstream file(test_db.path);
        file << R"({"38091": {"id": "repo1", "id": "repo2"}, "908": {"id": "repo3"}})";
        file.close();
        EXPECT_THROW({
            try {
                test_db.read_product_db();
            } catch (std::runtime_error &e) {
                EXPECT_STREQ(e.what(),
                    "The productdb file: 'test_product.json' has invalid format (value of collection is not array)");
                throw;
            }
        }, std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }

    /// Test invalid db format #3 (arrays do not contain strings)
    TEST_F(ProductDbTest, ReadInvalidDb3) {
        std::ofstream file(test_db.path);
        file << R"({"38091": [123, 456], "908": [789]})";
        file.close();
        EXPECT_THROW({
            try {
                test_db.read_product_db();
            } catch (std::runtime_error &e) {
                EXPECT_STREQ(e.what(),
                    "The productdb file: 'test_product.json' has invalid format (value of array is not string)");
                throw;
            }
        }, std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }

    TEST_F(ProductDbTest, ReadInvalidJson) {
        std::ofstream file(test_db.path);
        file << "invalid json";
        file.close();
        // It raises an exception with a very long message generated by a 3rd party library...
        EXPECT_THROW(test_db.read_product_db(), std::runtime_error);
        EXPECT_TRUE(test_db.products.empty());
    }
}

namespace test_to_json {
    TEST_F(ProductDbTest, EmptyDb) {
        const Json::Value json = test_db.to_json();
        EXPECT_TRUE(json.isObject());
        EXPECT_TRUE(json.empty());
    }

    TEST_F(ProductDbTest, SingleProduct) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");

        const Json::Value json = test_db.to_json();
        EXPECT_TRUE(json.isObject());
        EXPECT_TRUE(json.isMember("38091"));
        EXPECT_TRUE(json["38091"].isArray());
        EXPECT_EQ(json["38091"].size(), 1);
        EXPECT_EQ(json["38091"][0].asString(), "repo1");
    }

    TEST_F(ProductDbTest, MultipleProducts) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.products["908"].add_repo_id("repo3");

        Json::Value json = test_db.to_json();

        EXPECT_TRUE(json.isObject());
        EXPECT_TRUE(json.isMember("38091"));
        EXPECT_TRUE(json.isMember("908"));
        EXPECT_TRUE(json["38091"].isArray());
        EXPECT_TRUE(json["908"].isArray());
        EXPECT_EQ(json["38091"].size(), 2);
        EXPECT_EQ(json["908"].size(), 1);
        EXPECT_EQ(json["38091"][0].asString(), "repo1");
        EXPECT_EQ(json["38091"][1].asString(), "repo2");
        EXPECT_EQ(json["908"][0].asString(), "repo3");
    }
}

namespace test_write_product_db {
    TEST_F(ProductDbTest, WriteDbToEmptyPath) {
        test_db.path = "";
        EXPECT_FALSE(test_db.write_product_db());
    }

    TEST_F(ProductDbTest, WriteDbToNonExistentPath) {
        test_db.path = "/nonexistent/path/to/file.json";
        EXPECT_THROW({
            try {
                EXPECT_FALSE(test_db.write_product_db());
            } catch (std::runtime_error &e) {
                EXPECT_STREQ(e.what(),
                    "cannot create temporary file: (2) - No such file or directory [/nonexistent/path/to/productid.XXXXXX]");
                throw;
            }
        }, std::runtime_error);
    }

    TEST_F(ProductDbTest, WriteEmptyDb) {
        EXPECT_TRUE(test_db.write_product_db());
        std::ifstream file(test_db.path);
        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        EXPECT_EQ(content, "{}");
    }

    TEST_F(ProductDbTest, WriteEmptyDbToAbsolutePath) {
        // The directory '/tmp' should exist and should be writable by all users
        test_db.path = "/tmp/test_product.json";
        EXPECT_TRUE(test_db.write_product_db());
        std::ifstream file(test_db.path);
        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        EXPECT_EQ(content, "{}");
    }

    TEST_F(ProductDbTest, WriteValidDb) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.products["908"].add_repo_id("repo3");

        EXPECT_TRUE(test_db.write_product_db());

        std::ifstream file(test_db.path);
        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        EXPECT_TRUE(content.find("\"38091\"") != std::string::npos);
        EXPECT_TRUE(content.find("\"repo1\"") != std::string::npos);
        EXPECT_TRUE(content.find("\"repo2\"") != std::string::npos);
        EXPECT_TRUE(content.find("\"908\"") != std::string::npos);
        EXPECT_TRUE(content.find("\"repo3\"") != std::string::npos);
    }

    TEST_F(ProductDbTest, WriteAndReadDb) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.products["908"].add_repo_id("repo3");

        EXPECT_TRUE(test_db.write_product_db());

        ProductDb new_db;
        new_db.path = test_db.path;
        EXPECT_TRUE(new_db.read_product_db());
        EXPECT_EQ(new_db.products.size(), 2);
        EXPECT_TRUE(new_db.has_product_id("38091"));
        EXPECT_TRUE(new_db.has_product_id("908"));
        EXPECT_TRUE(new_db.products["38091"].has_repo_id("repo1"));
        EXPECT_TRUE(new_db.products["38091"].has_repo_id("repo2"));
        EXPECT_TRUE(new_db.products["908"].has_repo_id("repo3"));
    }
}

namespace test_add_repo_id {
    TEST_F(ProductDbTest, AddNewRepo) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        EXPECT_TRUE(test_db.has_product_id("38091"));
        EXPECT_TRUE(test_db.products["38091"].add_repo_id("repo1"));
        EXPECT_EQ(test_db.products["38091"].repos.size(), 1);
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo1"));
    }

    TEST_F(ProductDbTest, AddDuplicateRepo) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        EXPECT_TRUE(test_db.has_product_id("38091"));
        EXPECT_TRUE(test_db.products["38091"].add_repo_id("repo1"));
        EXPECT_FALSE(test_db.products["38091"].add_repo_id("repo1"));

        EXPECT_EQ(test_db.products["38091"].repos.size(), 1);
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo1"));
    }

    TEST_F(ProductDbTest, AddMultipleRepos) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.products["908"].add_repo_id("repo3");

        EXPECT_EQ(test_db.products.size(), 2);
        EXPECT_EQ(test_db.products["38091"].repos.size(), 2);
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo1"));
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo2"));
        EXPECT_EQ(test_db.products["908"].repos.size(), 1);
        EXPECT_TRUE(test_db.products["908"].has_repo_id("repo3"));
    }

    TEST_F(ProductDbTest, AddAndPersistRepo) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        EXPECT_TRUE(test_db.products["38091"].add_repo_id("repo1"));
        EXPECT_TRUE(test_db.write_product_db());

        ProductDb new_db;
        new_db.path = test_db.path;
        EXPECT_TRUE(new_db.read_product_db());
        EXPECT_TRUE(new_db.has_product_id("38091"));
        EXPECT_TRUE(new_db.products["38091"].has_repo_id("repo1"));
    }
}

namespace test_remove_product_id {
    TEST_F(ProductDbTest, RemoveExistingProduct) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["908"].add_repo_id("repo3");

        const auto ret = test_db.remove_product_id("38091");

        EXPECT_TRUE(ret);
        EXPECT_FALSE(test_db.has_product_id("38091"));
        EXPECT_TRUE(test_db.has_product_id("908"));
        EXPECT_EQ(test_db.products.size(), 1);
    }

    TEST_F(ProductDbTest, RemoveNonExistentProduct) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");

        const auto ret = test_db.remove_product_id("908");

        EXPECT_FALSE(ret);
        EXPECT_TRUE(test_db.has_product_id("38091"));
        EXPECT_EQ(test_db.products.size(), 1);
    }

    TEST_F(ProductDbTest, RemoveAndPersist) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["908"].add_repo_id("repo3");
        test_db.products["38091"].is_installed = true;
        test_db.products["908"].is_installed = true;

        EXPECT_TRUE(test_db.remove_product_id("38091"));
        EXPECT_TRUE(test_db.write_product_db());

        ProductDb new_db;
        new_db.path = test_db.path;
        EXPECT_TRUE(new_db.read_product_db());
        EXPECT_FALSE(new_db.has_product_id("38091"));
        EXPECT_TRUE(new_db.has_product_id("908"));
        EXPECT_EQ(new_db.products.size(), 1);
    }
}

namespace test_remove_repo_id {
    TEST_F(ProductDbTest, RemoveExistingRepo) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.add_product_id("908", "./test_data/908.pem");
        test_db.products["908"].add_repo_id("repo3");

        const auto ret = test_db.products["38091"].remove_repo_id("repo1");

        EXPECT_TRUE(ret);
        EXPECT_TRUE(test_db.has_product_id("38091"));
        EXPECT_FALSE(test_db.products["38091"].has_repo_id("repo1"));
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo2"));
        EXPECT_TRUE(test_db.products["908"].has_repo_id("repo3"));
        EXPECT_EQ(test_db.products["38091"].repos.size(), 1);
    }

    TEST_F(ProductDbTest, RemoveNonExistentProduct) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");

        const auto ret = test_db.products["908"].remove_repo_id("repo2");

        EXPECT_FALSE(ret);
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo1"));
        EXPECT_EQ(test_db.products["38091"].repos.size(), 1);
    }

    TEST_F(ProductDbTest, RemoveNonExistentRepo) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");

        const auto ret = test_db.products["38091"].remove_repo_id("repo2");

        EXPECT_FALSE(ret);
        EXPECT_TRUE(test_db.products["38091"].has_repo_id("repo1"));
        EXPECT_EQ(test_db.products["38091"].repos.size(), 1);
    }

    TEST_F(ProductDbTest, RemoveAndPersistRepo) {
        test_db.add_product_id("38091", "./test_data/38091.pem");
        test_db.products["38091"].add_repo_id("repo1");
        test_db.products["38091"].add_repo_id("repo2");
        test_db.products["38091"].is_installed = true;

        EXPECT_TRUE(test_db.products["38091"].remove_repo_id("repo1"));
        EXPECT_TRUE(test_db.write_product_db());

        ProductDb new_db;
        new_db.path = test_db.path;
        EXPECT_TRUE(new_db.read_product_db());
        EXPECT_FALSE(new_db.products["38091"].has_repo_id("repo1"));
        EXPECT_TRUE(new_db.products["38091"].has_repo_id("repo2"));
        EXPECT_EQ(new_db.products["38091"].repos.size(), 1);
    }
}

int main(int argc, char **argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
